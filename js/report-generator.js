// Advanced Report Generator v2.1 - PDF & HTML Export
const ReportGenerator = {
    
    // Generate comprehensive HTML report
    generateHTML(analysis, fileName, connections) {
        const ips = Utils.extractUniqueIPs(connections);
        const timestamp = new Date().toISOString();
        
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C2 Beacon Analysis Report - ${fileName}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #1f2937;
            background: #f9fafb;
            padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 3rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .header { border-bottom: 3px solid #3b82f6; padding-bottom: 1.5rem; margin-bottom: 2rem; }
        h1 { color: #1f2937; font-size: 2rem; margin-bottom: 0.5rem; }
        .meta { color: #6b7280; font-size: 0.875rem; }
        .badge {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 1.125rem;
            margin: 1rem 0;
        }
        .badge-critical { background: #dc2626; color: white; }
        .badge-high { background: #ea580c; color: white; }
        .badge-medium { background: #ca8a04; color: white; }
        .badge-info { background: #16a34a; color: white; }
        .score-container {
            background: #f3f4f6;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
        }
        .score { font-size: 3rem; font-weight: 700; color: #1f2937; }
        .section { margin: 2rem 0; }
        .section h2 {
            color: #1f2937;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        th, td {
            text-align: left;
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        th { background: #f9fafb; font-weight: 600; color: #374151; }
        .threat-match {
            background: #fef2f2;
            border-left: 4px solid #dc2626;
            padding: 1rem;
            margin: 1rem 0;
        }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin: 1rem 0; }
        .metric {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.375rem;
        }
        .metric-label { font-size: 0.75rem; color: #6b7280; text-transform: uppercase; }
        .metric-value { font-size: 1.5rem; font-weight: 700; color: #1f2937; }
        .footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 0.875rem;
        }
        @media print {
            body { background: white; padding: 0; }
            .container { box-shadow: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è C2 Beacon Analysis Report</h1>
            <div class="meta">
                Generated: ${new Date(timestamp).toLocaleString()}<br>
                Analyzed File: ${fileName}<br>
                Tool Version: 2.1.0
            </div>
        </div>

        <div class="section">
            <h2>Executive Summary</h2>
            <div class="badge badge-${analysis.severity}">${analysis.classification}</div>
            <div class="score-container">
                <div style="font-size: 0.875rem; color: #6b7280; margin-bottom: 0.5rem;">THREAT SCORE</div>
                <div class="score">${analysis.score}%</div>
            </div>
            <p><strong>Recommendation:</strong> ${analysis.recommendation}</p>
        </div>

        ${this.generateThreatIntelSection(analysis)}
        ${this.generateNetworkDataSection(connections, ips, analysis)}
        ${this.generateDetectionFactorsSection(analysis)}
        ${this.generateMLSection(analysis)}
        ${this.generateMITRESection(analysis)}
        ${this.generateFeaturesSection(analysis)}

        <div class="footer">
            <p><strong>Disclaimer:</strong> This report is generated by automated analysis and should be validated by security professionals.</p>
            <p>C2 Beacon Detector v2.1 | Powered by ThreatFox & Machine Learning</p>
        </div>
    </div>
</body>
</html>`;
    },

    generateThreatIntelSection(analysis) {
        if (!analysis.threatIntelMatches || analysis.threatIntelMatches.length === 0) {
            return '';
        }

        const matches = analysis.threatIntelMatches.map(match => `
            <div class="threat-match">
                <h3 style="color: #dc2626; margin-bottom: 0.5rem;">${match.ip}</h3>
                <p><strong>Malware:</strong> ${match.sources?.map(s => s.malware).join(', ') || match.malware}</p>
                <p><strong>Threat Type:</strong> ${match.sources?.[0]?.threat_type || match.threat_type}</p>
                <p><strong>Confidence:</strong> ${match.combinedThreatScore || match.confidence_level}%</p>
                <p><strong>Connections:</strong> ${match.connection_count}</p>
                ${match.sources ? `<p><strong>Sources:</strong> ${match.sources.map(s => s.source).join(', ')}</p>` : ''}
            </div>
        `).join('');

        return `
        <div class="section">
            <h2>‚ö†Ô∏è Threat Intelligence Matches</h2>
            <p>Found ${analysis.threatIntelMatches.length} known malicious indicator(s):</p>
            ${matches}
        </div>`;
    },

    generateNetworkDataSection(connections, ips, analysis) {
        return `
        <div class="section">
            <h2>üìä Network Data</h2>
            <div class="grid">
                <div class="metric">
                    <div class="metric-label">Total Connections</div>
                    <div class="metric-value">${connections.length}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Duration</div>
                    <div class="metric-value">${Utils.formatDuration(analysis.features.duration_minutes)}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Total Data</div>
                    <div class="metric-value">${Utils.formatBytes(analysis.features.total_bytes)}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Unique Dest IPs</div>
                    <div class="metric-value">${ips.destIPs.length}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Unique Ports</div>
                    <div class="metric-value">${analysis.features.unique_dest_ports}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Conn/Min</div>
                    <div class="metric-value">${analysis.features.connections_per_minute.toFixed(2)}</div>
                </div>
            </div>
            
            <h3 style="margin-top: 1.5rem;">Destination IPs</h3>
            <table>
                <tr><th>IP Address</th><th>Connection Count</th></tr>
                ${this.generateIPTable(connections, ips.destIPs)}
            </table>
        </div>`;
    },

    generateIPTable(connections, ips) {
        return ips.slice(0, 10).map(ip => {
            const count = connections.filter(c => Utils.getDestIP(c) === ip).length;
            return `<tr><td>${ip}</td><td>${count}</td></tr>`;
        }).join('');
    },

    generateDetectionFactorsSection(analysis) {
        return `
        <div class="section">
            <h2>üîç Detection Factors</h2>
            <ul style="list-style: none; padding: 0;">
                ${analysis.reasons.map(r => `<li style="padding: 0.5rem 0; border-bottom: 1px solid #e5e7eb;">${r}</li>`).join('')}
            </ul>
        </div>`;
    },

    generateMLSection(analysis) {
        if (!analysis.mlResults) return '';

        const ml = analysis.mlResults;
        return `
        <div class="section">
            <h2>ü§ñ Machine Learning Analysis</h2>
            <div class="grid">
                <div class="metric">
                    <div class="metric-label">ML Prediction</div>
                    <div class="metric-value">${ml.ensemble?.prediction || 'N/A'}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">ML Confidence</div>
                    <div class="metric-value">${ml.ensemble?.confidence || 'N/A'}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">ML Score</div>
                    <div class="metric-value">${ml.ensemble ? (ml.ensemble.score * 100).toFixed(1) + '%' : 'N/A'}</div>
                </div>
            </div>
            ${ml.models?.anomaly_detector?.is_anomaly ? '<p style="color: #dc2626; font-weight: 600;">‚ö†Ô∏è Anomaly detected by ML model</p>' : ''}
        </div>`;
    },

    generateMITRESection(analysis) {
        if (!analysis.mitreTechniques || analysis.mitreTechniques.length === 0) return '';

        return `
        <div class="section">
            <h2>üéØ MITRE ATT&CK Mapping</h2>
            <table>
                <tr><th>Technique ID</th><th>Name</th><th>Tactic</th><th>Description</th></tr>
                ${analysis.mitreTechniques.map(t => `
                    <tr>
                        <td><strong>${t.id}</strong></td>
                        <td>${t.name}</td>
                        <td>${t.tactic}</td>
                        <td>${t.description}</td>
                    </tr>
                `).join('')}
            </table>
        </div>`;
    },

    generateFeaturesSection(analysis) {
        const features = analysis.features;
        return `
        <div class="section">
            <h2>üìà Extracted Features</h2>
            <table>
                <tr><th>Feature</th><th>Value</th></tr>
                ${Object.entries(features).map(([key, value]) => `
                    <tr>
                        <td>${key.replace(/_/g, ' ')}</td>
                        <td>${typeof value === 'number' ? (value < 1 && value > 0 ? value.toFixed(4) : value.toFixed(2)) : value}</td>
                    </tr>
                `).join('')}
            </table>
        </div>`;
    },

    // Download HTML report
    downloadHTML(analysis, fileName, connections) {
        const html = this.generateHTML(analysis, fileName, connections);
        const blob = new Blob([html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `c2-report-${Date.now()}.html`;
        a.click();
        URL.revokeObjectURL(url);
    },

    // Generate PDF (using browser print)
    printToPDF(analysis, fileName, connections) {
        const html = this.generateHTML(analysis, fileName, connections);
        const printWindow = window.open('', '_blank');
        printWindow.document.write(html);
        printWindow.document.close();
        
        // Wait for content to load then trigger print
        setTimeout(() => {
            printWindow.print();
        }, 500);
    },

    // Generate enhanced JSON report
    generateJSON(analysis, fileName, connections) {
        const ips = Utils.extractUniqueIPs(connections);
        
        return {
            metadata: {
                tool: 'C2 Beacon Detector',
                version: '2.1.0',
                timestamp: new Date().toISOString(),
                analyzed_file: fileName,
                features_enabled: {
                    threat_intel: analysis.threatIntelMatches?.length > 0,
                    machine_learning: analysis.mlResults !== null,
                    historical_comparison: true
                }
            },
            summary: {
                score: analysis.score,
                classification: analysis.classification,
                severity: analysis.severity,
                recommendation: analysis.recommendation
            },
            threat_intelligence: {
                matches: analysis.threatIntelMatches || [],
                total_iocs_matched: analysis.threatIntelMatches?.length || 0,
                sources_used: analysis.threatIntelMatches?.flatMap(m => 
                    m.sources?.map(s => s.source) || []
                ).filter((v, i, a) => a.indexOf(v) === i) || []
            },
            machine_learning: analysis.mlResults || null,
            behavioral_analysis: {
                frameworks: analysis.identifiedFrameworks,
                mitre_techniques: analysis.mitreTechniques,
                detection_factors: analysis.reasons,
                technical_details: analysis.technicalDetails
            },
            network_data: {
                total_connections: connections.length,
                unique_dest_ips: ips.destIPs,
                unique_src_ips: ips.srcIPs,
                duration: Utils.formatDuration(analysis.features.duration_minutes),
                total_bytes: Utils.formatBytes(analysis.features.total_bytes),
                connections_per_ip: ips.destIPs.map(ip => ({
                    ip: ip,
                    count: connections.filter(c => Utils.getDestIP(c) === ip).length
                }))
            },
            features: analysis.features,
            raw_connections: connections.slice(0, 100) // Include sample of connections
        };
    }
};
